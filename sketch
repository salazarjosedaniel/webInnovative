/***************************************************
 *  Tasa Autom√°tica - ESP32 + 2x MAX7219 (USD / EUR)
 *  Backend propio (opci√≥n C):
 *     GET  /api/tasas
 *     {
 *       "usd": "36.72",
 *       "eur": "38.90",
 *       "fecha": "2025-11-16T13:00:21.201Z"
 *     }
 *
 *  Funcionalidades:
 *   - Portal WiFi (WiFiManager) + URL de API configurable
 *   - Watchdog (API nueva ESP32)
 *   - LED interno de estado (GPIO 2)
 *       NET_OK          -> LED fijo
 *       NET_NO_INTERNET -> parpadeo lento
 *       NET_NO_WIFI     -> parpadeo r√°pido
 *   - Auto-reconexi√≥n WiFi
 *   - Si pierde WiFi > 30s -> borra credenciales y reinicia
 ***************************************************/

#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <WiFiManager.h>    // https://github.com/tzapu/WiFiManager
#include <esp_task_wdt.h>

/************ Pines MAX7219 ************/
const uint8_t DIN_PIN    = 23;
const uint8_t CLK_PIN    = 18;
const uint8_t CS_USD_PIN = 5;   // M√≥dulo superior (USD)
const uint8_t CS_EUR_PIN = 4;   // M√≥dulo inferior (EUR)

/************ LED de estado ************/
const uint8_t LED_PIN = 2;

/************ Watchdog ************/
const int WDT_TIMEOUT_SECONDS = 10;

/************ Configuraci√≥n API ************/
String apiUrl = "";  // se llenar√° desde WiFiManager

/************ Estados de red ************/
enum NetState {
  NET_NO_WIFI,
  NET_NO_INTERNET,
  NET_OK
};

NetState netState = NET_NO_WIFI;

/************ Timers ************/
unsigned long lastLedToggle = 0;
bool ledOn = false;

unsigned long lastCall = 0;
const unsigned long INTERVALO_API = 10000;   // 10s (ajusta luego a 60s o m√°s)

unsigned long wifiFallidaDesde = 0;
const unsigned long TIEMPO_MAX_SIN_WIFI = 30000; // 30s

bool shouldRebootAfterConfig = false;

/************ Valores √∫ltimos ************/
String lastUsd  = "--.--";
String lastEur  = "--.--";
String lastFecha = "";

/************************************************
 *  Funciones b√°sicas para MAX7219
 *  (2 m√≥dulos independientes, comparten DIN/CLK)
 ************************************************/

void maxTransfer(uint8_t csPin, uint8_t address, uint8_t value)
{
  digitalWrite(csPin, LOW);
  shiftOut(DIN_PIN, CLK_PIN, MSBFIRST, address);
  shiftOut(DIN_PIN, CLK_PIN, MSBFIRST, value);
  digitalWrite(csPin, HIGH);
}

void initModule(uint8_t csPin)
{
  pinMode(csPin, OUTPUT);
  digitalWrite(csPin, HIGH);

  // Apagar test
  maxTransfer(csPin, 0x0F, 0x00);
  // Decode mode: BCD en los 8 d√≠gitos
  maxTransfer(csPin, 0x09, 0xFF);
  // Escanear los 8 d√≠gitos (0‚Äì7)
  maxTransfer(csPin, 0x0B, 0x07);
  // Intensidad (0x00‚Äì0x0F)
  maxTransfer(csPin, 0x0A, 0x08);  // brillo medio
  // Salir de shutdown (encender)
  maxTransfer(csPin, 0x0C, 0x01);

  // Limpiar d√≠gitos
  for (uint8_t d = 1; d <= 8; d++)
    maxTransfer(csPin, d, 0x0F);   // 0x0F = ‚Äúblank‚Äù en decode mode
}

void clearModule(uint8_t csPin)
{
  for (uint8_t d = 1; d <= 8; d++)
    maxTransfer(csPin, d, 0x0F);
}

/**
 * Muestra un n√∫mero en un m√≥dulo, formato texto, ej: "236.46"
 * MAX7219 en decode mode BCD:
 *  - 0‚Äì9 -> d√≠gitos
 *  - 0x0F -> en blanco
 *  - 0x0A -> gui√≥n
 *  - bit 7 (0x80) -> punto decimal
 *
 * Usamos solo los 6 d√≠gitos de la derecha, el m√≥dulo tiene 8.
 */
void showNumberOnModule(uint8_t csPin, String num)
{
  clearModule(csPin);

  // Asegurar que no supere 8 caracteres (por seguridad)
  if (num.length() > 8)
    num = num.substring(num.length() - 8);

  // Para tasa usamos m√°x 6 posiciones: "236.46"
  while (num.length() < 6) {
    num = " " + num;  // rellenar con espacios a la izquierda
  }

  bool dpNext = false;   // el pr√≥ximo d√≠gito llevar√° decimal point
  uint8_t digitPos = 1;  // MAX7219 usa direcciones 1‚Äì8 (derecha a izquierda)

  for (int i = num.length() - 1; i >= 0 && digitPos <= 8; i--) {
    char c = num[i];

    if (c == '.') {
      dpNext = true;   // el punto se aplica al d√≠gito anterior
      continue;
    }

    uint8_t value;

    if (c >= '0' && c <= '9') {
      value = (uint8_t)(c - '0');
    } else if (c == ' ') {
      value = 0x0F;  // en blanco
    } else if (c == '-') {
      value = 0x0A;  // gui√≥n
    } else {
      value = 0x0F;  // cualquier otra cosa: blanco
    }

    if (dpNext) {
      value |= 0x80; // bit de decimal point
      dpNext = false;
    }

    maxTransfer(csPin, digitPos, value);
    digitPos++;
  }
}

/************************************************
 *  Callbacks WiFiManager
 ************************************************/
void saveConfigCallback() {
  Serial.println("üíæ WiFiManager: configuraci√≥n guardada.");
  shouldRebootAfterConfig = true;
}

/************************************************
 *  Watchdog
 ************************************************/
void initWatchdog() {
  esp_task_wdt_config_t wdt_config = {
    .timeout_ms = WDT_TIMEOUT_SECONDS * 1000,
    .idle_core_mask = (1 << 0),
    .trigger_panic = true
  };

  esp_task_wdt_init(&wdt_config);
  esp_task_wdt_add(NULL);
}

/************************************************
 *  LED indicador
 ************************************************/
void actualizarLed() {
  unsigned long now = millis();

  switch (netState) {
    case NET_OK:
      digitalWrite(LED_PIN, HIGH); // fijo
      break;

    case NET_NO_INTERNET:
    {
      // parpadeo lento
      const unsigned long intervalo = 500;
      if (now - lastLedToggle >= intervalo) {
        lastLedToggle = now;
        ledOn = !ledOn;
        digitalWrite(LED_PIN, ledOn ? HIGH : LOW);
      }
      break;
    }

    case NET_NO_WIFI:
    {
      // parpadeo r√°pido
      const unsigned long intervalo = 150;
      if (now - lastLedToggle >= intervalo) {
        lastLedToggle = now;
        ledOn = !ledOn;
        digitalWrite(LED_PIN, ledOn ? HIGH : LOW);
      }
      break;
    }
  }
}

/************************************************
 *  Verificar WiFi + auto resetSettings
 ************************************************/
void verificarWiFi() {

  if (WiFi.SSID() == "") {
    netState = NET_NO_WIFI;
    return;
  }

  if (WiFi.status() != WL_CONNECTED) {

    if (wifiFallidaDesde == 0) {
      wifiFallidaDesde = millis();
    }

    netState = NET_NO_WIFI;
    Serial.println("‚ö†Ô∏è WiFi desconectado. Intentando reconectar...");

    WiFi.reconnect();
    delay(500);

    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("‚úî WiFi reconectado.");
      wifiFallidaDesde = 0;
      return;
    }

    Serial.println("‚ùå No se pudo reconectar.");

    if (millis() - wifiFallidaDesde > TIEMPO_MAX_SIN_WIFI) {
      Serial.println("\n‚õî WiFi perdido >30s. Borrando configuraci√≥n y reiniciando...");
      WiFiManager wm;
      wm.resetSettings();
      delay(1500);
      ESP.restart();
    }

  } else {
    wifiFallidaDesde = 0;
  }
}

/************************************************
 *  Consulta a la API
 ************************************************/
bool consultarAPI() {

  verificarWiFi();

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ùå Sin WiFi");
    netState = NET_NO_WIFI;
    return false;
  }

  if (apiUrl == "") {
    Serial.println("‚ùå URL API vac√≠a");
    netState = NET_NO_INTERNET;
    return false;
  }

  Serial.println("\nüåê Consultando API de tasas...");

  HTTPClient http;
  http.setTimeout(4000);
  http.begin(apiUrl);

  int httpCode = http.GET();

  if (httpCode == 200) {
    String payload = http.getString();
    Serial.println("üì• Respuesta API:");
    Serial.println(payload);

    StaticJsonDocument<256> doc;
    DeserializationError err = deserializeJson(doc, payload);

    if (err) {
      Serial.print("‚ùå ERROR JSON: ");
      Serial.println(err.c_str());
      netState = NET_NO_INTERNET;
      http.end();
      return false;
    }

    lastUsd   = doc["usd"].as<String>();
    lastEur   = doc["eur"].as<String>();
    lastFecha = doc["fecha"].as<String>();

    Serial.println("\nüìå TASAS RECIBIDAS");
    Serial.print("USD: ");
    Serial.println(lastUsd);
    Serial.print("EUR: ");
    Serial.println(lastEur);
    Serial.print("Fecha: ");
    Serial.println(lastFecha);

    netState = NET_OK;
    http.end();
    return true;

  } else {
    Serial.print("‚ùå ERROR HTTP: ");
    Serial.println(httpCode);
    netState = NET_NO_INTERNET;
    http.end();
    return false;
  }
}

/************************************************
 *  SETUP
 ************************************************/
void setup() {
  Serial.begin(115200);
  delay(500);

  Serial.println();
  Serial.println("=====================================");
  Serial.println("üöÄ INICIANDO TASA AUTOM√ÅTICA v1.0");
  Serial.println("=====================================");

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  pinMode(DIN_PIN, OUTPUT);
  pinMode(CLK_PIN, OUTPUT);

  // Inicializar m√≥dulos MAX7219
  initModule(CS_USD_PIN);
  initModule(CS_EUR_PIN);

  // Mensaje inicial: guiones
  showNumberOnModule(CS_USD_PIN, "--.--");
  showNumberOnModule(CS_EUR_PIN, "--.--");

  // ------ Portal WiFi (sin watchdog) ------
  WiFiManager wm;

  WiFiManagerParameter apiField(
    "apiurl",
    "URL API",
    "https://web-innovative.vercel.app/api/tasas",   // <-- reempl√°zala por la tuya si quieres
    200
  );
  wm.addParameter(&apiField);

  wm.setSaveConfigCallback(saveConfigCallback);

  Serial.println("üì° Iniciando portal WiFi (BCV-TasaAutomatica) si no hay config...");

  if (!wm.autoConnect("Tasa-Automatica")) {
    Serial.println("‚ùå Fallo en portal. Reiniciando...");
    delay(1500);
    ESP.restart();
  }

  Serial.println("‚úî WiFi configurado / conectado.");
  Serial.print("üì° IP: ");
  Serial.println(WiFi.localIP());

  apiUrl = apiField.getValue();
  Serial.print("üîó API URL: ");
  Serial.println(apiUrl);

  if (shouldRebootAfterConfig) {
    Serial.println("‚úî Nueva configuraci√≥n guardada.");
    Serial.println("‚è≥ Esperando 15s antes de reiniciar...");

    for (int i = 15; i > 0; i--) {
      Serial.print("   Reinicio en ");
      Serial.print(i);
      Serial.println("s");
      delay(1000);
    }
    ESP.restart();
  }

  // A partir de aqu√≠: modo RUN
  initWatchdog();
  netState = NET_NO_INTERNET; // hasta primera respuesta OK
}

/************************************************
 *  LOOP
 ************************************************/
void loop() {

  esp_task_wdt_reset();  // alimentar watchdog

  if (millis() - lastCall > INTERVALO_API) {
    lastCall = millis();

    bool ok = consultarAPI();

    if (ok) {
      // Mostrar en displays
      showNumberOnModule(CS_USD_PIN, lastUsd);
      showNumberOnModule(CS_EUR_PIN, lastEur);
    } else {
      // Error: mostrar guiones
      showNumberOnModule(CS_USD_PIN, "--.--");
      showNumberOnModule(CS_EUR_PIN, "--.--");
    }
  }

  actualizarLed();
  delay(20);
}

